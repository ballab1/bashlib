#!/bin/bash

#----------------------------------------------------------------------------------------------
#
#   versions.bashlib; basic functions to access 'versions' repo
#
#----------------------------------------------------------------------------------------------

#----------------------------------------------------------------------------------------------
function versions.data()
{
    local -r deploy_yaml=${1:?}
    local commit=${2:-}

    local -r deploy_json="$(lib.yamlToJson "$deploy_yaml")"

    local key val
    local -A VERSIONS=()
    while read -r key; do
        val="$(jq --compact-output --monochrome-output --raw-output '.versions.'"$key" <<< "$deploy_json")"
        VERSIONS[$key]="$(eval echo "$val")"
    done < <(jq --compact-output --monochrome-output --raw-output '.versions|keys[]' <<< "$deploy_json")

    # temporarily reduce DEBUG_TRACE to prevent 'git' tracing
    (
        if [ "${commit:-}" ]; then
            (( DEBUG_TRACE-- )) ||:
            if versions.initialize "$commit"; then
                commit=$(versions.lastCommit)
                if [ "$commit" != "${VERSIONS['commit']}" ]; then
                    sed -E -i 's|commit:.*$|commit: '${commit}'|' "$deploy_yaml"
                fi
            fi
            (( DEBUG_TRACE++ )) ||:
        fi
    )

    local container_os="$(jq --compact-output --monochrome-output --raw-output 'try .container_os' <<< "$deploy_json" ||:)"
    versions.export "$container_os"
}
export -f versions.data

#----------------------------------------------------------------------------------------------
function versions.export()
{
    local -r containerOS=${1:?}

    # export data for requested OS
    local -r versions="$(readlink -m "${VERSIONS['dir']}/$containerOS")"
    [ -e "$versions" ] || trap.die "Unrecognized CONTAINER_OS: $containerOS"

    lib.exportFileVars "$versions" 'export'
}
export -f versions.export

#----------------------------------------------------------------------------------------------
function versions.initialize()
{
    local commit=${1:-}

    local -r versions_dir="${VERSIONS['dir']}"
    if [ ! -d "$versions_dir" ]; then
        mkdir -p "$(dirname "$versions_dir")" || trap.die 'no version information available'
        git.clone "${VERSIONS['repo']}" "$versions_dir"  --quiet
    fi
    cd "$versions_dir"
    VERSIONS['dir']="$(pwd)"

    # return if versions directory is dirty
    versions.isNotDirty || return 1

    # ensure version info is up-to-date
    if [ "${commit^^:-}" = 'HEAD' ]; then
        if ! git.checkout "${VERSIONS['commit']}" --quiet ; then
            cd ..
            rm -rf "$versions_dir"
            git.clone "${VERSIONS['repo']}" "$versions_dir" --no-checkout
            cd "$versions_dir"
            git.checkout "${VERSIONS['commit']}" --quiet
        fi
        return 1
    fi
    return 0
}
export -f versions.initialize

#----------------------------------------------------------------------------------------------
function versions.isNotDirty()
{
    [[ "$(git describe --tags --always --dirty)" != *-dirty ]]
}
export -f versions.isNotDirty

#----------------------------------------------------------------------------------------------
function versions.lastCommit()
{
    git.checkout "${VERSIONS['branch']:-master}" &>/dev/null
    git.reset --hard 'HEAD~1' &>/dev/null
    git.pull --quiet
    git.HEAD
}
export -f versions.lastCommit

#----------------------------------------------------------------------------------------------
